{{- if .Values.cleanupOnUninstall }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "kube-freezer.fullname" . }}-cleanup
  namespace: {{ include "kube-freezer.namespace" . }}
  labels:
    {{- include "kube-freezer.labels" . | nindent 4 }}
  annotations:
    # Run this job after Helm uninstalls all resources
    "helm.sh/hook": post-delete
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "kube-freezer.selectorLabels" . | nindent 8 }}
        component: cleanup
    spec:
      # Note: ServiceAccount might be deleted by Helm before this hook runs
      # The cleanup job needs cluster-admin permissions via the ServiceAccount
      # If ServiceAccount is gone, this job will fail - that's expected
      # In that case, manually delete remaining resources
      serviceAccountName: {{ include "kube-freezer.serviceAccountName" . }}
      restartPolicy: OnFailure
      containers:
      - name: cleanup
        image: {{ .Values.certificate.generatorImage | default "bitnami/kubectl:latest" }}
        command:
        - /bin/bash
        - -c
        - |
          # Don't use set -e - we want to continue even if some deletions fail
          set -x  # Enable debug output for troubleshooting
          
          NAMESPACE="{{ include "kube-freezer.namespace" . }}"
          RELEASE_NAME="{{ .Release.Name }}"
          
          echo "üßπ Starting cleanup of KubeFreezer resources..."
          echo ""
          
          # Wait a moment for Helm to finish deleting managed resources
          echo "‚è≥ Waiting for Helm to finish deleting managed resources..."
          sleep 3
          
          # Check if namespace exists
          if ! kubectl get namespace "${NAMESPACE}" &>/dev/null; then
            echo "   Namespace '${NAMESPACE}' already deleted, nothing to clean up."
            exit 0
          fi
          
          # Delete specific secrets by name (more reliable than --all)
          echo "üóëÔ∏è  Deleting secrets..."
          for secret in kube-freezer-tls kube-freezer-api-keys; do
            if kubectl delete secret "${secret}" -n "${NAMESPACE}" --ignore-not-found=true 2>&1; then
              echo "   ‚úÖ Deleted secret: ${secret}"
            else
              echo "   ‚ö†Ô∏è  Failed to delete secret: ${secret}"
            fi
          done
          
          # Delete specific ConfigMaps by name (these are not managed by Helm)
          echo "üóëÔ∏è  Deleting ConfigMaps..."
          for cm in kube-freezer-exemptions kube-freezer-schedules kube-freezer-notifications kube-freezer-templates; do
            if kubectl delete configmap "${cm}" -n "${NAMESPACE}" --ignore-not-found=true 2>&1; then
              echo "   ‚úÖ Deleted configmap: ${cm}"
            else
              echo "   ‚ö†Ô∏è  Failed to delete configmap: ${cm}"
            fi
          done
          
          # Delete any remaining jobs (except this one)
          echo "üóëÔ∏è  Deleting jobs..."
          kubectl delete jobs -n "${NAMESPACE}" --ignore-not-found=true --field-selector metadata.name!=${RELEASE_NAME}-cleanup || true
          
          # Delete any remaining pods (orphaned pods)
          echo "üóëÔ∏è  Deleting pods..."
          kubectl delete pods -n "${NAMESPACE}" --all --ignore-not-found=true 2>/dev/null || true
          
          # Delete PVCs if any
          echo "üóëÔ∏è  Deleting PVCs..."
          kubectl delete pvc -n "${NAMESPACE}" --all --ignore-not-found=true 2>/dev/null || true
          
          # Delete the namespace itself
          echo "üóëÔ∏è  Deleting namespace '${NAMESPACE}'..."
          if kubectl get namespace "${NAMESPACE}" &>/dev/null; then
            kubectl delete namespace "${NAMESPACE}" --ignore-not-found=true --wait=false || true
            echo "   Namespace deletion initiated (may take a moment to complete)"
          else
            echo "   Namespace already deleted"
          fi
          
          # Clean up ValidatingWebhookConfiguration (if not already deleted)
          echo "üóëÔ∏è  Cleaning up ValidatingWebhookConfiguration..."
          WEBHOOK_NAME="{{ include "kube-freezer.fullname" . }}"
          kubectl delete validatingwebhookconfiguration "${WEBHOOK_NAME}" --ignore-not-found=true || true
          
          # Clean up ClusterRole and ClusterRoleBinding (if not already deleted)
          echo "üóëÔ∏è  Cleaning up cluster-level resources..."
          CLUSTER_ROLE="{{ include "kube-freezer.fullname" . }}"
          CLUSTER_ROLE_BINDING="{{ include "kube-freezer.fullname" . }}"
          kubectl delete clusterrole "${CLUSTER_ROLE}" --ignore-not-found=true || true
          kubectl delete clusterrolebinding "${CLUSTER_ROLE_BINDING}" --ignore-not-found=true || true
          
          echo ""
          echo "‚úÖ Cleanup completed!"
          echo ""
          echo "Note: Namespace deletion may take a few moments to complete."
          echo "You can check with: kubectl get namespace ${NAMESPACE}"
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          runAsNonRoot: true
          runAsUser: 1000
        resources:
          limits:
            cpu: 100m
            memory: 128Mi
          requests:
            cpu: 50m
            memory: 64Mi
{{- end }}

