{{- if and (not .Values.certificate.useCertManager) (not .Values.certificate.manual) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "kube-freezer.fullname" . }}-cert-generator
  namespace: {{ include "kube-freezer.namespace" . }}
  labels:
    {{- include "kube-freezer.labels" . | nindent 4 }}
  annotations:
    # Helm hooks to run before install/upgrade
    # Note: Completed jobs may remain after uninstall as they are hook resources
    # They can be safely deleted manually if needed
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "kube-freezer.selectorLabels" . | nindent 8 }}
        component: cert-generator
    spec:
      serviceAccountName: {{ include "kube-freezer.serviceAccountName" . }}
      restartPolicy: OnFailure
      containers:
      - name: cert-generator
        image: {{ .Values.certificate.generatorImage | default "bitnami/kubectl:latest" }}
        command:
        - /bin/bash
        - -c
        - |
          set -e
          
          NAMESPACE="{{ include "kube-freezer.namespace" . }}"
          SERVICE_NAME="{{ include "kube-freezer.fullname" . }}-backend"
          SECRET_NAME="{{ include "kube-freezer.fullname" . }}-tls"
          CERT_DIR="/tmp/certs"
          
          echo "üîê Generating TLS certificates for webhook..."
          
          # Create certs directory
          mkdir -p "${CERT_DIR}"
          
          # Generate private key
          openssl genrsa -out "${CERT_DIR}/tls.key" 2048
          
          # Generate certificate signing request
          openssl req -new -key "${CERT_DIR}/tls.key" \
            -out "${CERT_DIR}/tls.csr" \
            -subj "/CN=${SERVICE_NAME}.${NAMESPACE}.svc"
          
          # Generate self-signed certificate with proper SANs
          # Using 99 years expiration (maximum practical limit for most systems)
          # This is effectively "never expire" for operational purposes
          openssl x509 -req -in "${CERT_DIR}/tls.csr" \
            -signkey "${CERT_DIR}/tls.key" \
            -out "${CERT_DIR}/tls.crt" \
            -days 36500 \
            -extensions v3_req \
            -extfile <(
              cat <<EOF
          [req]
          distinguished_name = req_distinguished_name
          req_extensions = v3_req
          
          [v3_req]
          basicConstraints = CA:TRUE
          keyUsage = nonRepudiation, digitalSignature, keyEncipherment, keyCertSign
          subjectAltName = @alt_names
          
          [alt_names]
          DNS.1 = ${SERVICE_NAME}
          DNS.2 = ${SERVICE_NAME}.${NAMESPACE}
          DNS.3 = ${SERVICE_NAME}.${NAMESPACE}.svc
          DNS.4 = ${SERVICE_NAME}.${NAMESPACE}.svc.cluster.local
          EOF
            )
          
          # Check if Secret exists and validate the certificate before generating new one
          REGENERATE_CERT=true
          if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" &>/dev/null; then
            echo "   Existing Secret found. Checking certificate validity..."
            # Extract existing certificate and check expiration
            EXISTING_CERT=$(kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" \
              -o jsonpath='{.data.tls\.crt}' | base64 -d 2>/dev/null || echo "")
            
            if [ -n "$EXISTING_CERT" ]; then
              # Save existing cert to temp file for validation
              echo "$EXISTING_CERT" > "${CERT_DIR}/existing.crt"
              
              # Check if certificate is expired or will expire soon (within 30 days)
              EXPIRY_DATE=$(openssl x509 -in "${CERT_DIR}/existing.crt" -noout -enddate 2>/dev/null | cut -d= -f2 || echo "")
              
              if [ -n "$EXPIRY_DATE" ]; then
                CURRENT_DATE=$(date +%s)
                EXPIRY_TIMESTAMP=$(date -j -f "%b %d %H:%M:%S %Y %Z" "$EXPIRY_DATE" +%s 2>/dev/null || \
                                  date -d "$EXPIRY_DATE" +%s 2>/dev/null || echo "0")
                
                if [ "$EXPIRY_TIMESTAMP" -gt 0 ]; then
                  DAYS_REMAINING=$(( ($EXPIRY_TIMESTAMP - $CURRENT_DATE) / 86400 ))
                  
                  if [ "$DAYS_REMAINING" -lt 0 ]; then
                    echo "   ‚ö†Ô∏è  Certificate has EXPIRED (expired $(( -$DAYS_REMAINING )) days ago). Regenerating..."
                  elif [ "$DAYS_REMAINING" -lt 30 ]; then
                    echo "   ‚ö†Ô∏è  Certificate expires soon (in $DAYS_REMAINING days). Regenerating..."
                  else
                    echo "   ‚úÖ Certificate is valid (expires in $DAYS_REMAINING days)"
                    echo "   Reusing existing certificate..."
                    REGENERATE_CERT=false
                  fi
                else
                  echo "   ‚ö†Ô∏è  Could not parse certificate expiration. Regenerating for safety..."
                fi
              else
                echo "   ‚ö†Ô∏è  Could not read certificate expiration. Regenerating..."
              fi
              
              # Clean up temp file
              rm -f "${CERT_DIR}/existing.crt"
            else
              echo "   ‚ö†Ô∏è  Secret exists but certificate is empty or invalid. Regenerating..."
            fi
          else
            echo "   No existing Secret found. Creating new certificate..."
          fi
          
          # Generate new certificate if needed
          if [ "$REGENERATE_CERT" = true ]; then
            # Base64 encode the newly generated certificate and key
            TLS_CRT=$(cat "${CERT_DIR}/tls.crt" | base64 | tr -d '\n')
            TLS_KEY=$(cat "${CERT_DIR}/tls.key" | base64 | tr -d '\n')
            
            # Update or create Secret
            if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" &>/dev/null; then
              echo "   Updating Secret with new certificate..."
              kubectl patch secret "${SECRET_NAME}" \
                --namespace="${NAMESPACE}" \
                --type='json' \
                -p="[{\"op\": \"replace\", \"path\": \"/data/tls.crt\", \"value\":\"${TLS_CRT}\"}, {\"op\": \"replace\", \"path\": \"/data/tls.key\", \"value\":\"${TLS_KEY}\"}]"
            else
              echo "   Creating new Secret..."
              kubectl create secret tls "${SECRET_NAME}" \
                --namespace="${NAMESPACE}" \
                --cert="${CERT_DIR}/tls.crt" \
                --key="${CERT_DIR}/tls.key" \
                --dry-run=client -o yaml | kubectl apply -f -
            fi
            
            # Use the newly generated certificate for CA bundle
            CA_BUNDLE="${TLS_CRT}"
          else
            # Extract CA bundle from existing certificate in secret
            echo "   Using existing certificate for CA bundle..."
            CA_BUNDLE=$(kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" \
              -o jsonpath='{.data.tls\.crt}')
          fi
          
          WEBHOOK_NAME="{{ include "kube-freezer.fullname" . }}"
          
          echo "   Updating ValidatingWebhookConfiguration with CA bundle..."
          kubectl patch validatingwebhookconfiguration "${WEBHOOK_NAME}" \
            --type='json' \
            -p="[{\"op\": \"replace\", \"path\": \"/webhooks/0/clientConfig/caBundle\", \"value\":\"${CA_BUNDLE}\"}]" || \
          echo "   Warning: ValidatingWebhookConfiguration not found yet, will be updated after webhook is created"
          
          echo "‚úÖ Certificate generated and applied successfully!"
          
          # Generate API key if secret doesn't exist
          echo ""
          echo "üîë Checking API key secret..."
          API_KEY_SECRET_NAME="kube-freezer-api-keys"
          if kubectl get secret "${API_KEY_SECRET_NAME}" -n "${NAMESPACE}" &>/dev/null; then
            echo "   API key secret already exists, skipping key generation."
            echo "   To generate a new key, delete the secret and upgrade the release."
          else
            echo "   Generating default API key for admin user..."
            API_KEY=$$(openssl rand -hex 16)
            FULL_KEY="kf-admin-$$API_KEY"
            echo "   Generated API key: $$FULL_KEY"
            # Create the secret
            kubectl create secret generic "${API_KEY_SECRET_NAME}" \
              --from-literal=api_key_admin="$$FULL_KEY" \
              --namespace="${NAMESPACE}" \
              --dry-run=client -o yaml | kubectl apply -f -
            # Add Helm labels for proper management
            kubectl label secret "${API_KEY_SECRET_NAME}" \
              --namespace="${NAMESPACE}" \
              app.kubernetes.io/name=kube-freezer \
              app.kubernetes.io/instance=kube-freezer \
              app.kubernetes.io/managed-by=Helm \
              --overwrite || true
            echo "   ‚úÖ API key secret created: ${API_KEY_SECRET_NAME}"
            echo "   ‚ö†Ô∏è  Save this key securely: $$FULL_KEY"
            echo "   To view the key later:"
            echo "     kubectl get secret ${API_KEY_SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.api_key_admin}' | base64 -d && echo"
          fi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          runAsNonRoot: true
          runAsUser: 1000
        resources:
          limits:
            cpu: 100m
            memory: 128Mi
          requests:
            cpu: 50m
            memory: 64Mi
{{- end }}

