# Default values for kube-freezer
# Namespace configuration
namespace: kube-freezer
# Set to false when using Helm's --create-namespace flag to avoid conflicts
# The namespace template will only create the namespace if this is true AND --create-namespace is not used
createNamespace: false

# Cleanup configuration
# If true, a post-delete hook will clean up ALL resources including namespace, secrets, ConfigMaps, etc.
# WARNING: This will delete everything in the namespace, including data not managed by Helm
# Set to false if you want to preserve data after uninstall
cleanupOnUninstall: true

# Backend configuration
backend:
  enabled: true
  replicaCount: 2
  image:
    repository: fadihussien/kubefreezer
    pullPolicy: IfNotPresent
    tag: "0.5.10"
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi

# Frontend configuration
frontend:
  enabled: true
  replicaCount: 2
  image:
    repository: fadihussien/kubefreezer-ui
    pullPolicy: IfNotPresent
    tag: "0.1.0"
  resources:
    limits:
      cpu: 200m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi


nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true

service:
  backend:
    type: ClusterIP
    port: 443
  frontend:
    type: ClusterIP
    port: 80

nodeSelector: {}

tolerations: []

affinity: {}

# ConfigMap configuration
config:
  freeze_enabled: "false"
  freeze_until: ""
  freeze_message: "Deployment freeze is active. Use bypass annotation or contact oncall."
  bypass_annotation_key: "admission-controller.io/emergency-bypass"
  bypass_allowed_users: |
    system:serviceaccount:default:test-user
  # API Authorization: ServiceAccounts allowed to use the REST API
  # Format: system:serviceaccount:<namespace>:<name>
  # SECURITY: If empty, NO ServiceAccounts are allowed (deny by default)
  # You MUST configure this to allow any ServiceAccount to use the API
  # Example:
  # api_allowed_serviceaccounts: |
  #   system:serviceaccount:kube-freezer:kube-freezer
  #   system:serviceaccount:production:api-user
  api_allowed_serviceaccounts: |
    system:serviceaccount:kube-freezer:kube-freezer
  bypass_exempt_namespaces: |
    kube-system
    kube-public
    kube-node-lease
    kube-freezer
  monitored_resources: |
    - deployments
    - statefulsets
    - daemonsets
  fail_closed: "true"
  # Note: freeze_schedule is now stored in a separate ConfigMap (kube-freezer-schedules)
  # This ConfigMap is created during installation and is NOT managed by Helm
  # This prevents schedules from being deleted during Helm upgrades

# Certificate configuration
# Kubernetes webhooks REQUIRE HTTPS - TLS is mandatory
# 
# Certificate generation options:
# 1. Automatic (default): A Helm hook Job will generate certificates automatically
# 2. Manual: Provide your own certificates via values.yaml (see manual section below)
# 3. cert-manager: Use cert-manager for automatic certificate management (set useCertManager: true)
#
certificate:
  # Use cert-manager for automatic certificate management
  useCertManager: false  # Set to true if using cert-manager
  
  # Manual certificate configuration (set manual: true and provide cert/key)
  # If manual: true, you must provide both cert and key
  manual: false  # Set to true to provide your own certificates
  cert: ""  # Base64-encoded certificate (PEM format) - required if manual: true
  key: ""   # Base64-encoded private key (PEM format) - required if manual: true
  caBundle: ""  # Base64-encoded CA bundle for webhook - optional, will use cert if not provided
  generatorImage: "bitnami/kubectl:latest"  # Container image for certificate generation Job (must have kubectl and openssl)

# Webhook configuration
webhook:
  failurePolicy: Fail  # Fail or Ignore
  timeoutSeconds: 5
  # Rules for which resources to intercept
  rules:
    - apiGroups: ["apps"]
      apiVersions: ["v1"]
      operations: ["CREATE", "UPDATE"]
      resources: ["deployments", "statefulsets", "daemonsets"]
      scope: "*"

# NetworkPolicy
networkPolicy:
  enabled: false  # Disabled - user prefers no network restrictions

# Notifications (Slack only)
notifications:
  enabled: false
  providers: []
  # Example Slack configuration:
  # providers:
  #   - type: slack
  #     enabled: true
  #     webhook_url: "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
  #     channel: "#deployments"  # Optional: override default channel (requires webhook permission)
  #     username: "KubeFreezer"  # Optional: override bot username
  #     icon_emoji: ":lock:"  # Optional: override bot icon emoji
  #     events:
  #       - freeze_enabled
  #       - freeze_disabled
  #       - violation
  #       - schedule_reminder
  #       - schedule_removed
  #       - exemption_created

# All templates must be configured here - no built-in templates
# Now using cron expressions for simpler and more flexible scheduling
templates:
  enabled: true  # Set to true to enable templates feature
  customTemplates:
    # ============================================
    # CRON-BASED SCHEDULES - Using standard cron expressions
    # ============================================
    # Cron format: "minute hour day month day-of-week"
    # - Freeze is active when cron matches, until end of that day (or schedule end date)
    # - Schedule must have: name, start, end, cron, message (optional: namespaces)
    
    # ============================================
    # WEEKEND BLACKOUT PERIOD
    # ============================================
    # Freeze all day on Saturdays and Sundays
    # Active year-round, every weekend
    - name: "weekend-blackout"
      description: "Weekend blackout period - all day Saturday and Sunday"
      schedule:
        start: "2025-01-01T00:00:00Z"  # Start of year (update annually)
        end: "2025-12-31T23:59:59Z"    # End of year (update annually)
        cron: "0 0 * * 0,6"             # Saturday and Sunday at midnight UTC (0=Sunday, 6=Saturday)
      message: "Weekend blackout period - no deployments allowed on weekends"
      # Optional: Restrict to specific namespaces
      # namespaces: ["production", "staging"]
    
    # ============================================
    # HOLIDAY BLACKOUT PERIOD
    # ============================================
    # Major holidays: Christmas week and New Year
    # Freeze active all day during these periods
    - name: "holiday-blackout"
      description: "Holiday blackout period - Christmas week and New Year"
      schedule:
        start: "2025-12-23T00:00:00Z"  # Start before Christmas
        end: "2026-01-03T23:59:59Z"    # End after New Year
        cron: "0 0 * * *"               # Daily at midnight UTC - freeze active all day
      message: "Holiday blackout period - no deployments during holiday season"
      # Optional: Restrict to specific namespaces
      # namespaces: ["production"]
    
    # ============================================
    # MAINTENANCE WINDOW BLACKOUT
    # ============================================
    # Monthly maintenance window - 1st Monday of each month
    # Freeze all day on the 1st Monday of each month
    - name: "maintenance-window-blackout"
      description: "Monthly maintenance window - 1st Monday of each month"
      schedule:
        start: "2025-01-01T00:00:00Z"  # Start of year (update annually)
        end: "2025-12-31T23:59:59Z"    # End of year (update annually)
        cron: "0 0 1-7 * 1"            # Monday at midnight UTC, first 7 days of month (1 = Monday)
      message: "Monthly maintenance window - no deployments during scheduled maintenance"
      # Optional: Restrict to specific namespaces
      # namespaces: ["production", "staging"]

